# 初级排序算法

**选择排序**
首先,找到数组中最小(或者最大)的那个元素,其次,将它和数组的第一个元素交换位置(如果第一个元素就是最小(或最大)元素那么它就和自己交换).再次,在剩下的元素中找到最小(或最大)的元素,将它与数组的第二个元素交换位置.如此往复,知道将整个数组排序.这种方法叫做选择排序.

```java
//选择排序
int a[] = {3,9,45,25,69,1,24,89,40};
for(int i= 0; i<a.length;i++) {
	int min = i; // 最小值的索引
	for (int j = i+1; j<a.length; j++) {
		if (a[min] > a[j]) {
			min = j;
		}
	}
	int temp = a[i];
	a[i] = a[min];
	a[min] = temp;
}
System.out.println(Arrays.toString(a));
```
**插入排序**
每趟将一个元素,按照其关键字的大小插入到它前面已经排序号的子序列中,依次重复,直到插入全部元素.
```java
//插入排序
int a[] = {3,9,45,69,25,1,24,89,40};
for (int i=1; i<a.length; i++) {
	int min=a[i];
	int j;
	//将a[i]插入到 a[i-1],a[i-2],a[i-3]...之中
	for (j = i-1; j>=0&&min<a[j]; j--) {
		a[j+1] = a[j]; // 当min<a[j]的时候,就是将min插入j的位置
	}
	a[j+1] = min;
}
System.out.println(Arrays.toString(a));
```

**希尔排序**
希尔排序又称为缩小增量排序,基本思路是分组的直接插入排序.
由直接插入排序算法分析可知,若数据序列接近有序,则时间效率越高;当n较小时,时间效率也很高.希尔排序基于这两点对直接插入排序进行了改进.
算法描述:
- 将一个数据序列分成若干组,每组由若干相隔一段距离(称为增量)的元素组成,在一个组内采用直接插入排序算法进行排序.
- 增量初值通常为数据序列长度的一半,以后每趟增量减半,最后值为1.随着增量逐渐减少,组数也减少,组内元素个数增加,数据序列接近有序.

希尔排序的思想是使数组中任意间隔为h 的元素都是有序的。这样的数组被称为h 有序数组。换
句话说，一个h 有序数组就是h 个互相独立的有序数组编织在一起组成的一个数组（见图2.1.2）。
在进行排序时，如果h 很大，我们就能将元素移动到很远的地方，为实现更小的h 有序创造方便。用
这种方式，对于任意以1 结尾的h 序列，我们都能够将数组排序。这就是希尔排序。算法2.3 的实现
使用了序列1/2（3k-1），从N/3 开始递减至1。我们把这个序列称为递增序列。算法2.3 实时计算了
它的递增序列，另一种方式是将递增序列存储在一个数组中。
一个h 有序数组即一个由h 个有序子数组组成的数组
实现希尔排序的一种方法是对于每个h，用插入排序将h 个子数组独立地排序。但因为子数组
是相互独立的，一个更简单的方法是在h- 子数组中将每个元素交换到比它大的元素之前去（将比它
大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由1 改为h 即可。这样，希
尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。
```java
//希尔排序
int a[] = {3,9,45,69,25,1,24,89,40};
int N = a.length;
int h = 1;
while(h < N/3) h = 3*h + 1;
while (h >= 1) {
	// 将数组变成h有序
	for (int i=h; i < N; i++) {
		//将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中
		for (int j=i; j>=h && a[j]<a[j-h]; j -=h) {
			a[j] = a[j] + a[j-h];
			a[j-h] = a[j] - a[j-h];
			a[j] = a[j] - a[j-h];
		}
	}
	h = h/3;
}
System.out.println(Arrays.toString(a));
```


#归并排序
归并排序(MERGE-SORT)是利用归并的思想实现的排序方法,该算法采用经典的分治(divide-and-conquer)策略(分治法将问题分(divide)成一些小的问题然后递归求解,而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起,即分而治之).

**自顶向下的归并排序**
自顶向下的排序算法就是把数组元素不断的二分,直到子数组的元素个数为一个,因为这个时候子数组必定是已有序的,然后将两个有序的序列合并成一个新的有序的序列,两个新的有序序列又可能合并成另一个新的有序序列,以此类推,直到合并成一个有序的数组.
为了体现归并排序的稳定性,我们的代码使用Java的泛型来实现对任意对象的排序
```java
import java.util.Arrays;

public class Merge {

	private static int aux[]; // 归并所需的辅助数组
	public static void merge(int a[], int lo, int mid, int hi) {
		// 将a[lo..mid] 和 a[mid+1..hi]归并
		int i = lo, j = mid + 1;
		for (int k = lo; k <= hi; k++) {
			// 将a[lo..hi]复制到aux[lo..hi]
			aux[k] = a[k];
		}
		for (int k = lo; k <= hi; k++) {
			// 归并回到a[lo..hi]
			if(i > mid)
				a[k] = aux[j++];
			else if(j > hi)
				a[k] = aux[i++];
			else if(aux[j]<aux[i])
				a[k] = aux[j++];
			else
				a[k] = aux[i++];
		}
	}
	public static void sort(int a[]) {
		aux = new int[a.length]; //一次性分配空间
		sort(a, 0, a.length-1);
	}
	private static void sort(int a[], int lo, int hi) {
		// 将数组a[lo...hi]排序
		if(hi <= lo) return;
		int mid = lo + (hi - lo) / 2;
		sort(a, lo, mid); // 将左半边排序
		sort(a, mid+1, hi); // 将右半边排序
		merge(a, lo, mid, hi); //归并结果
	}
	public static void main(String[] args) {

		//自顶向下的归并排序
		int a[] = {3,9,45,69,25,1,24,89,40};
		sort(a);
		System.out.println(Arrays.toString(a));
	}
}
```

**自底向上的归并排序**
自底向上的归并排序算法的思想就是数组中先一个一个归并成两两有序的序列,两两有序的序列归并成四个四个有序的序列,然后四个四个有序的序列归并八个八个有序的序列,依次类推,直到归并的长度大于整个数组的长度,此时整个数组有序.需要注意的是数组按照归并长度划分,最后一个子数组可能不满足长度要求,这个情况需要特殊处理.自顶向下的归并排序算法一般用递归来实现,而自底向上的归并排序可以用循环来实现.
```java

import java.util.Arrays;

public class MergeBU {

	private static Comparable[] aux; // 归并所需的辅助数组

	public static void merge(Comparable[] a, int lo, int mid, int hi) {
		// 将a[lo..mid] 和 a[mid+1..hi]归并
		int i = lo, j = mid + 1;
		for (int k = lo; k <= hi; k++) {
			// 将a[lo..hi]复制到aux[lo..hi]
			aux[k] = a[k];
		}
		for (int k = lo; k <= hi; k++) {
			// 归并回到a[lo..hi]
			if(i > mid)
				a[k] = aux[j++];
			else if(j > hi)
				a[k] = aux[i++];
			else if(aux[j].compareTo(aux[i])<0)
				a[k] = aux[j++];
			else
				a[k] = aux[i++];
		}
	}

	public static void sort(Comparable[] a) {
		// 进行 lgN次两两归并
		int N = a.length;
		aux = new Comparable[N];
		for (int sz=1; sz <N; sz = sz + sz) //sz子数组大小
			for (int lo = 0; lo < N-sz; lo += sz + sz) { //lo:子数组索引
				merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
			}
	} 
	public static void main(String[] args) {

		//自顶向下的归并排序
		Integer a[] = {3,9,45,69,25,1,24,89,40};
		sort(a);
		System.out.println(Arrays.toString(a));
	}
}
```
当数组长度为2的幂时,自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同,只是顺序不同,其它时候,两种方法的比较和数组访问的次序或有所不同.
自底向上的归并排序比较适合用链表组织的数据.

#快速排序
快速排序是一种分治的排序算法,它将一个数组分成两个子数组,将两部分独立地排序.快速排序和归并排序是互补的;归并排序将数组分成两个子数组分别排序,并将有序的子数组归并以将整个数组排序;而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了.

**基本算法**
```java
//快速排序
import java.util.Arrays;

public class QuickSort {

	public static void sort(Comparable[] a) {
		sort(a, 0, a.length - 1);
	}
	public static void sort(Comparable[] a, int lo, int hi) {
		if(hi <= lo) return;
		int j = partition(a, lo, hi); //切分
		sort(a, lo, j-1); // 将左半部分a[lo...j-1]排序
		sort(a, j+1, hi); // 将有半部分a[j+1...hi]排序
	}
	// 快速排序的切分,将数组a[lo..hi]进行切分,使得[lo..j-1] <= a[j] <= a[j+1...hi]
	// 并返回索引
	private static int partition(Comparable[] a, int lo, int hi) {
		// 将数组切分成a[lo...i-1],a[i],a[i+1...hi]
		int i = lo, j = hi + 1; //左右扫描指针
		Comparable v = a[lo]; //切分元素
		while(true) {
			// 扫描左右,检查扫描是否结束并交换元素
			while(a[++i].compareTo(v)<0) if(i == hi) break;
			while(v.compareTo(a[--j])<0) if(j == lo) break;
			if(i >= j) break;
			exchange(a, i, j);
		}
		exchange(a, lo, j); //将 v = a[j]放入正确的位置
		return j; //a[lo...j-1] <= a[j] <= a[j+1..hi] 达成
	}
	private static void exchange(Object[] a, int i, int j) {
		Object swap = a[i];
		a[i] = a[j];
		a[j] = swap;
	}
	public static void main(String[] args) {

		//快速排序
		Integer a[] = {3,9,45,69,25,1,24,89,40};
		sort(a);
		System.out.println(Arrays.toString(a));
	}
}
```
**三向切分的快速排序**
```java
import java.util.Arrays;

//三向切分的快速排序
public class Quick3waySort {

	public static void sort(Comparable[] a) {
		sort(a, 0, a.length - 1);
	}
	private static void sort(Comparable[] a, int lo, int hi) {

		if (hi <= lo) return;
		int lt = lo, i = lo + 1, gt = hi;
		Comparable v = a[lo];
		while(i <= gt) {
			int cmp = a[i].compareTo(v);
			if(cmp < 0) exchange(a, lt++, i++);
			else if(cmp > 0) exchange(a, i, gt--);
			else i++;
		} //现在 a[lo...lt-1] <= v = a[lt...gt] < a[gt+1...hi]成立
		sort(a, lo, lt-1);
		sort(a, gt + 1, hi);
	}
	private static void exchange(Object[] a, int i, int j) {
		Object swap = a[i];
		a[i] = a[j];
		a[j] = swap;
	} 
	public static void main(String[] args) {

		//三向切分的快速排序
		Integer a[] = {3,9,45,69,25,1,24,89,40};
		sort(a);
		System.out.println(Arrays.toString(a));
	}
}
```

# 优先队列
一个合适的数据结构应该支持两种操作,删除最大元素和插入元素.这种数据类型叫做优先队列.
优先队列的使用和队列(删除最老的元素)以及栈(删除最新的元素)类似,但高效地实现它则更有挑战性.
优先队列是一种抽象数据类型,它表示了一组值和对这些值的操作.
优先队列最重要的操作就是删除最大元素和插入元素.

##初级实现
####数组实现(无序)
####数组实现(有序)
####链表表示法

##堆排序
```java
//堆排序
public class HeapSort {
	public static void sort(Comparable[] pq) {
		int n = pq.length;
		for(int k = n/2; k >=1; k--) 
			sink(pq, k, n);
		while(n > 1) {
			exchange(pq, 1, n--);
			sink(pq, 1, n);
		}
	}
	private static void sink(Comparable[] pq, int k, int n) {
		while(2*k <= n) {
			int j = 2*k;
			if (j < n && less(pq, j, j+1)) j++;
			if (!less(pq, k, j)) break;
			exchange(pq, k, j);
			k = j;
		}
	}

	private static boolean less(Comparable[] pq, int i, int j) {
		return pq[i-1].compareTo(pq[j-1]) < 0;
	}
	private static void exchange(Object[] pq, int i , int j) {
		Object swap = pq[i-1];
		pq[i-1] = pq[j-1];
		pq[j-1] = swap;
	}
	// print array to standard output  将数组打印输出
	private static void show(Comparable[] a) {
		for (int i = 0; i < a.length; i++)
			System.out.print(a[i] + " ");
		System.out.println();
	}
	public static void main(String[] args) {
        //堆排序
		Integer a[] = {3,9,45,69,25,1,24,89,40,15,595,238,666,42,5,99};
		HeapSort.sort(a);
		show(a);
	}
}
```