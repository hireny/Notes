本文主要在了解数据链路层基本概念和功能的基础上，终点掌握滑动窗口机制、三种可靠传输协议、各种MAC协议、HDLC协议和PPP协议，特别是CSMA/CD协议和以太网帧格式，以及局域网的征用期和最小帧长的概念、二进制指数退避算法。此外，中继器、网卡、集线器、网桥和局域网交换机的原理及区别也要重点掌握。

# 数据链路层的功能

数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。

## 为网络层提供服务

对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。数据链路层通常可为网络层提供如下服务：

1. **无确认的无连接服务**。源机器发送数据帧时不需先建立建立连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网。
2. **有确认的无连接服务**。源机器发送数据帧时不需先建立数据连接，但目的主机收到数据帧时必须发回确认。源机器在所规定的时间内未收到确认信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信。
3. **有确认的面向连接服务**。帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因而该服务的可靠性最高。该服务适用于通信要求（可靠性、实时性）较高的场合。

注意：右链接就一定要有确认，即不存在无确认的面向连接服务。

## 链路管理

数据链路层连接的建立、维持和释放过程称为 **链路管理**，它主要用于面向连接的服务链路两端的结点要进行通信，必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中则要能维持连接，而在传输完毕后要释放该连接。在多个站点共享同一物理信道的情况下（例如在局域网中）如何在要求通信的站点间分配和管理信道也属于数据链路层管理的范畴。

## 帧定界、帧同步与透明传输

两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。将一段数据的前后分别添加首部和尾部，就构成了帧。首部和尾部中含有很多控制信息，它们的一个重要作用是确定帧的界限，即帧定界。而帧同步指的是接收方应能从接收到的二进制比特流中区分出帧的起始与终止。如在 HDLC 通信规程中，用标识位 F（01111110）来标识帧的开始和结束。通信过程中，检测到帧标识位 F 即认为是帧的开始，然后一旦检测到帧标识位 F 即表示帧的结束。HDLC 标准帧格式如下图所示。

images（王道）

如果在数据中恰好出现与帧定界符相同的比特组合（会误认为“传输结束”而丢弃后面的数据），那么就要采取有效的措施解决这个问题，即透明传输，更确切地说，透明传输就是不管所传数据时什么样的比特组合，都应当能在链路上传送。

## 流量控制

由于收发双方各自的工作速率和缓存空间的差异，可能出现发送方的发送能力大于接收方的接收能力的现象，如若此时不适当限制发送方的发送速率（即连路上的信息流量），前面来不及接收的帧将会被后面不断发送来的帧 “淹没”，造成帧丢失而出错。因此，流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。

这个过程需要通过某种反馈机制使发送方能够知道接收方是否能跟上自己，即需要有一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后继续发送。

如下图所示，流量控制并不是数据链路层特有的功能，许多协议中也提供此功能，只不过控制的对象不同而已。对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量，而对于传输层来说，控制的则是从源端到目的端之间的流量。

images（王道）

## 差错控制

由于信道噪声等各种原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为 **差错控制**。通常，这些错误可分为位错和帧错。

位错指帧中某些位出现了差错。通常采用循环冗余校验（CRC）方式发现位错，通过自动重传请求（Automatic Repeat reQuest，ARQ）方式来重传出错的帧。具体做法是：让发送方将要发送的数据帧附加一定的 CRC 冗余检错码一并发送，接收方则根据检错码对数据帧进行错误检测，若发现错误则丢弃，发送方超时重传该数据帧。这种差错控制方法称为 ARQ 法。ARQ 法只需返回很少的控制信息就可有效地确认所发数据帧是否被正确接收。

帧错指帧的丢失、重复或失序等错误。在数据链路层引入定时器和编号机制能保证每一帧最终都能有且仅有一次正确地交付给目的结点。

# 组帧

数据链路层之所以要把比特组合成帧为单位传输，是为了在出错时只重发出错的帧，而不必重发全部数据，从而提高效率。为了使接收方能正确地接收并检查所传输的帧，发送方必须依据一定的规则把网络层递交的分组封装成帧，称为组帧。组帧主要解决帧定界、帧同步、透明传输等问题。通常有以下4中方法实现组帧。

注意：组帧时既要加首部，又要加尾部。原因是，在网络中信息是以帧为最小单位进行传输的，所以接收端要正确地接收帧，必须要清除该帧在一串比特流中从哪里开始到哪里结束（因为接收端收到的是一串比特流，没有首部和尾部是不能正确区分帧的），而分组（即 IP 数据报）仅是包含在帧中的数据部分，所以不需要加尾部来定界。

## 字符计数法

如下图所示，字符计数法是指在帧头部使用一个计数字段来标明帧内字符数。目的结点的数据链路层收到字节计数值时，就知道后面跟随的字节数，从而可以确定帧结束的位置（计数字段提供的字节数包含自身所占用的一个字节）。

images（王道）

这种方法最大的问题在于如果计数字段出错，即失去了帧边界划分的依据，那么接收方就无法判断所传输帧的结束位和下一帧的开始位，收发双发将失去同步，从而造成灾难性后果。

## 字符填充的首尾定界符法

字符填充法使用一些特定的字符来定界一帧的开始（DLE STX）与结束（DEL ETX），为了使信息位中出现的特殊字符不被误判为帧的首尾定界符，可以在特殊字符前面填充一个转义字符（DLE）来加以区分（注意，转义字符是 ASCII 码中的控制字符，是一个字符，而非 “D” “L” “E” 三个字符的组合），以实现数据的透明传输。接收方收到转义字符后，就知道其后面紧跟着的是数据信息，而不是控制信息。

如下图（a）所示的字符帧，帧的数据段中出现 DLE 字符，发送方在每个 DLE 字符前再插入一个 DLE 字符[见下图（b）]，接收方收到数据后会自己删除这个插入的 DLE 字符，结果仍得到原来的数据[见下图（c）]。这也正是字符填充法名称的由来。

images（王道）

## 比特填充的首尾标志法

如下图所示，比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。它使用一个特定的比特模式，即 01111110 来标志一帧的开始和结束。为了不使信息位中出现的比特流 01111110 被误判为帧的首尾标志，发送方的数据链路层在信息位中遇到 5 个连续的 “1” 时，将自动在其后插入一个 “0”；而接收方做该过程的逆操作，即每收到 5 个连续的 “1” 时，自动删除后面紧跟着的 “0”，以恢复原信息。

images（王道）

比特填充法很容易由硬件来实现，性能优于字符填充法。

## 违规编码法

在物理层进行比特编码时，通常采用违规编码法。例如，曼彻斯特编码方法将数据比特 “1” 编码成 “高-低” 电平对，将数据比特 “0” 编码成 “低-高” 电平对，而 “高-高” 电平对和 “低-低” 电平对在数据比特中是违法的（即没有采用）。可以借用这些违规编码序列来定界帧的起始和终止。局域网 IEEE 802 标准就采用了这种方法。

违规编码法不需要采用任何填充技术，便能实现数据传输的透明性，但它只适用于采用冗余编码的特殊编码环境。

由于字节计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是比特填充法和违规编码法。

# 差错控制

概括地说，传输中的差错都是由噪声引起的。噪声有两大类：一类是信道所固有的、持续存在的随机热噪声；另一类是由外界特定的短暂原因所造成的冲击噪声。前者可以通过提高信噪比来减少或避免干扰，而后者不可能靠提高信号幅度来避免干扰造成的差错，是产生差错的重要原因。

通常利用编码技术进行差错控制，主要有两类：自动重传请求（Automatic RetransmissionreQuest，ARQ）和前向纠错（Forward Error Correction，FEC）。在 ARQ 方式中，接收端检测出差错时，就设法通知发送端重发，直到接收到正确的码字为止。在 FEC 方式中，接收端不但能发现差错，而且能确定二进制数码的错误为止，从而加以纠正。因此，差错控制又可分为检错编码（Error-Detecting Code）和纠错编码（Error-Correcting Code）。

## 检错编码

注意：建议结合《计算机组成原理考研复习指导》第 2 章有关检验码的内容对比复习。

检错编码都采用冗余编码技术，其核心思想是在有效数据（信息位）被发送前，先按某种关系附加一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使得码字遵从不变的规则。接收端根据收到的码字是否仍符合原规则来判断是否出错。常见的检错编码有奇偶校验码和循环冗余码。

### 奇偶校验码

奇偶校验码是奇校验码和偶校验码的统称，是一种最基本的检错码。它由 n-1 位信息元和 1位校验元组成，如果是奇校验码，那么在附加一个校验元后，码长为 n 的码字中 “1” 的个数为奇数；如果是偶校验码，那么在附加一个校验元以后，码长为 n 的码字中 “1” 的个数为偶数。它又分为垂直奇偶校验、水平奇偶校验和水平垂直奇偶校验。

### 循环冗余码

循环冗余码（Cyclic Redundancy Code，CRC）又称多项式码，任何一个由二进制数位串组成的代码都可以与一个只含有 0 和 1 两个系数的多项式建立一一对应关系。一个 k 位帧可以视为从 $X^{k-1}$ 到 $X^0$ 的 k 次多项式的系数序列，这个多项式的阶数为 k-1，高位是 $X^{k-1}$项的系数，下一位是 $X^{k-2}$的系数，依次类推。例如，1110011 有 7 位，表示成多项式是 $X^6+X^5+X^4+X+1$，而多项式 $X^5+X^4+X^2+X$ 对应的位串是 110110，其运算过程如下图所示。

images（王道）

给定一个 m bit 的帧或报文，发送器生成一个 r bit 的序列，称为帧检验序列（FCS）。这样所形成的帧将由 m+r 比特组成。发送方和接收方事先商定一个多项式 G(x)（最高位和最低位必须为 1），使这个带检验码的帧刚好能被预先确定的多项式 G(x) 整除。接收方用相同的多项式去除收到的帧，如果无余数，那么认为无差错。

假设一个帧有 m 位，其对应的多项式为 M(x)，则计算冗余码的步骤如下：

1. 加 0。假设 G(x) 的阶为 r，在帧的低位端加上 r 个 0。
2. 模 2 除，利用模 2 除法，用 G(x) 对应的数据串去除 1 中计算出的数据串，得到的余数即为冗余码（共 r 位，前面的 0 不可省略）。

多项式以 2 为模运算。按照模 2 运算规则，加法不进位，减法不借位，它刚好是异或操作。乘除法类似于二进制的运算，只是在做加减法时按模 2 规则进行。

冗余码的计算举例：设 G(x) = 1101（即 r = 3），待传送数据 M=101001（即 m=6），经模 2 除法运算后的结果是：商 Q=110101（这个商没什么用），余数 R = 001。所以发送出去的数据为 101001 001（即 $2^rM + FCS$），共有 m+r 位。循环冗余码的运算过程如上图所示。

### 纠错编码

在数据通信的过程中，解决差错问题的一种方法是在每个要发送的数据块上附加足够的冗余信息，使接收方能够推导出发送方实际送出的应该是什么样的比特串。最常见的纠错编码是海明码，它能发现双比特错，但只能纠正单比特错。

海明编码将码字内的位从左至右依次编号，第 1 位是 1 号，第 2 位是 2 号······第 n 位是 n 号，编号为 2 的幂的位（1号位、2号位、4号位、8号位等）是校验码，其余的位填入 m 位数据。每个校验位的取值应使得包括自身在内的一些位的集合服从规定的奇偶性（如偶性要求这些位的集合中 1 的个数是偶数）。为了知道编号为 k 的数据位对哪些校验位有影响，将编号 k 改写成 2 的幂的和，如 11 = 1+2+8,29=1+4+8+16。一个位只由扩展式中所示编号的位检测，如编号为 11 的位只由编号为 1、2 和 8 的校验位检测。

m 个信息位插入 r 个校验位组成 m+r 位码字，它们必须满足的关系是 $2^r \geq m+r+1$。以典型的 4 位数据编码为例，海明码将加入 3 个校验码，从而实际传输 7 位码字：

数据位： 1 2 3 4 5 6
代码：$P_1$ $P_2$ $D_1$ $P_3$ $D_2$ $D_3$ $D_4$

说明：$P_x$为校验码，$D_x$为数据码。

现以数据码 1101 为例讲述海明码的编码原理。此时 $D_1=1$，$D_2=1$，$D_3=0$，$D_4=1$，对于数据位的编号，有 $1=1$，$2=2$，$3=1+2$，$4=4$，$5=1+4$，$6=2+4$，$7=1+2+4$。于是 $P_1$ 对应数据位1，3，5，7，令$P_1 \oplus D_1 \oplus D_2 \oplus D_4=0$（表示异或运算），得$P_1=1$；$P_2$对应的数据位为2，3，6，7，令$P_2 \oplus D_1 \oplus D_3 \oplus D_4=0$，的$P_2=0$；$P_3$对应的数据位为4，5，6，7，令$P_3 \oplus D_2 \oplus D_3 \oplus D_4=0$，的$P_3=0$。因此，海明编码的结果就是 1010101。

接下来讨论如何纠错。接收方收到的正确码字应是 1010101，如果 $D_3$ 在传输途中因干扰而变成了 1，那么接收方就收到了 1010111。检测时，$P_1 \oplus D_1 \oplus D_2 \oplus D_4=0$，第一位纠错代码为0，正确。$P_2 \oplus D_1 \oplus D_3 \oplus D_4=1$，第二位纠错代码为1，有错误。$P_3 \oplus D_2 \oplus D_3 \oplus D_4=1$，第三位纠错代码为1，有错误。有三个纠错代码从高到低排列为二进制编码 110，换算成十进制数就是 6，也就是说第 6 位数据错了，而数据 $D_3$ 在海明编码后的位置正好是第 6 位，取反即可。

# 流量控制与可靠传输机制

