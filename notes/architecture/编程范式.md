本章讲述三个编程范式，它们分别是结构化编程（structured programming）、面向对象编程（object-oriented programming）以及函数式编程（functional programming）。

# 结构化编程

结构化编程是第一个普遍被采用的编程范式（但是却不是第一个被提出的），由 Edsger Wybe Dijkstra 于 1968 年最先提出。与此同时，Dijkstra 还论证了使用 goto 这样的无限制跳转语句将会损害程序的整体结构。接下来的章节我们还会说到，也是这位 Dijkstra 最先主张用我们现在熟知的 `if/then/else` 语句和 `do/while/until` 语句来代替跳转语句的。

我们可以将结构化编程范式归结为一句话：

结构化编程对程序控制权的直接转移进行了限制和规范。

# 面向对象编程

说到编程领域中第二个被广泛采用的编程范式，当然就是面向对象编程了。事实上，这个编程范式的提出比结构化编程还早了两年，是在 1966 年由 Ole Johan Dahl 和 Kriste Nygaard 在论文中总结归纳出来的。这两个程序员注意到了 ALGOL 语言中，函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这个函数就成为了一个类（class）的构造函数，而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法（method）。这样一来，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。

在这里，我们也可以用一句话来总结面向对象编程：

卖相对象编程对程序的控制权的间接转移进行了限制和规范。

# 函数式编程

尽管第三个编程范式是近些年才刚刚开始被采用的，但它其实是三个范式中最先被发明的。事实上，函数式编程概念是基于与阿兰·图灵同时代的数学家 Alonzo Church 在 1936 年发明的 λ 演算的直接衍生物。1958 年 John Mccarthy 利用其作为基础发明了 LISP 语言。众所周知，λ 演算法的一个核心思想是不可变性 —— 某个符号所对应的值是永远不变的，所以从理论上来说，函数式编程语言中应该是没有赋值语句的。大部分函数式编程语言只允许在非常严格的限制条件下，才可以更改某个变量的值。

因此，我们在这里可以将函数式编程范式总结为下面这句话：

函数式编程对程序中的赋值进行了限制和规范。

# 仅供思考

如你所见，我在介绍三个编程范式的时候，有意采用了上面这种格式，目的是凸显每个编程范式的实际含义 —— 它们都从某一方面限制和规范了程序员的能力。没有一个范式是增加新能力的。也就是说，每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。

另外，我们应该认识到，这三个编程范式分别限制了 goto 语句、函数指针和赋值语句的使用。那么除此之外，还有什么可以去除的呢？

没有了。因此这三个编程范式可能是仅有三个了 —— 如果单论去除能力的编程范式的话。支持者一结论的另外一个论据是，三个编程范式都是在 1958 年到 1968 年这 10 年间被提出来的，后续再也没有新的编程范式出现过。

# 本章小结

大家可能会问，这些编程范式的历史知识与软件架构有关系吗？当然有，而且关系相当密切。譬如说，多态是我们跨域架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各模块的算法实现基础。

这和软甲架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。

# 结构化编程

Edsger Wybe Dijkstra 于1930 年出生在荷兰鹿特丹。生于乱世，他亲身经历了第二次世界大战中的鹿特丹大轰炸、德国占领荷兰等事件。1948 年， 他以数学、物理、化学以及生物全满分的成绩高中毕业。1952 年3 月，年仅21 岁的Dijkstra （此时距离我出生还有9 个月时间）入职荷兰阿姆斯特丹数学中心，成为了荷兰的第一个程序员。

1955 年，在从事编程工作3 年之后，当时还是一个学生的Dijkstra 就认为编程相比理论物理更有挑战性，因此他选择将编程作为终身职业。

1957 年， Dijkstra 与Maria Debets 结婚了。在当时的荷兰， 新郎新娘必须在结婚仪式上公布自己的职业。而当时的荷兰官方政府拒绝承认“程序员”这一职业，因为他们从来没有听说过。最终D甘kstra 不得不继续使用“理论物理学家”这一职位名称。

Dijkstra 和他的老板Adriaan van Wijingaarden 曾经讨论过将“程序员”当作终身职业这件事， D甘kstra 最担心的是由于没有人认真地对待过编程这件事或者将它当作是一门学术学科对待， 他的科研成果可能将不会得到认真对待。而Adriaan 则建议Dijkstra ： 为什么不亲自去开创这门学科呢？

当时还是真空管阶段。计算机体积巨大，运行缓慢，还非常容易出故障，功能（与今天对比〉十分有限。人们还是直接使用二进制数，或者使用非常原始的汇编语言编程。计算机的输入方式则还是用纸卷带或者是打孔卡片。要想执行完整的编辑、编译、测试流程是非常耗时的，通常需要数小时或者数天才能完成。

Dijkstra 就是在这样原始的条件下做出其非凡的成就的。

## 可推导性

Dijkstra 很早就得出的结论是：编程是一项难度很大的活动。一段程序无论复杂与否，都包含了很多的细节信息。如果没有工具的帮助，这些细节的信息是远远超过一个程序员的认知能力范围的。而在一段程序中，哪怕仅仅是一个小细节的错误，也会造成整个程序出错。

Dijkst ra 提出的解决方案是采用数学推导方法。他的想法是借鉴数学中的公理( Pos tul ate ）、定理（ Th eore m ）、推论（ C orollary ）和引理（ Lemma ），形成一种欧几里得结构。D ijk s tra 认为程序员可以像数学家一样对自己的程序进行推理证明。换句话说，程序员可以用代码将一些己证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。

当然，在这之前，必须先展示如何推导证明简单算法的正确性，这本身就是一件极具挑战性的工作。

Dij kstra 在研究过程中发现了一个问题： goto 语句的某些用法会导致某个模块无法被递归拆分成更小的、可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的部分。

goto i吾句的其他用法虽然不会导致这种问题，但是D ijkstra 意识到它们的实际效果其实和更简单的分支结构if - then - else 以及循环结构do - while 是一致的。如果代码中只采用了这两类控制结构，则一定可以将程序分解成更小的、可证明的单元。

事实上， Dij kstra 很早就知道将这些控制结构与顺序结构的程序组合起来很有用。因为在两年前， B o hm 和Jo c opi ni 刚刚证明了人们可以用顺序结构、分支结构、循环结构这三种结构构造出任何程序。

这个发现非常重要： 因为它证明了我们构建可推导模块所需要的控制结构集与构建所有程序所需的控制结构集的最小集是等同的。这样一来，结构化编程就诞生了。

Dijks tr a 展示了顺序结构的正确性可以通过枚举法证明，其过程与其他一般的数学推导过程是一样的：针对序列中的每个输入，跟踪其对应的输出值的变化就可以了。

同样的， D ij kstra 利用枚举法又证明了分支结构的可推导性。因为我们只要能用枚举法证明分支结构中每条路径的正确性，自然就可以推导出分支结构本身的正确性。

循环结构的证明过程则有些不同，为了证明一段循环程序的正确性， Dijkstra 需要采用数学归纳法。具体来说就是，首先要用枚举法证明循环1 次的正确性。接下来再证明如果循环N 次是正确的，那么循环N＋ ！ 次也同样也是正确的。最后还要用枚举法证明循环结构的起始与结束条件的正确性。

尽管这些证明过程本身非常复杂和烦琐，但确实是完备的。有了这样的证明过程，用欧几里得层级构造定理的方式来验证程序正确性的目标，貌似近在咫尺了。

## goto 是有害的

1968 年， Dijkstra 曾经给CACM 的编辑写过一封信。这封信后来发表于CACM 3 月刊，标题是Go To Statement Considered Harmfu/1, Dijkstra 在信中具体描绘了他对三种控制结构的看法。

这可捅了个大篓子。由于当时还没有互联网， 大家还不能直接上网发帖来对Dijkstra 进行冷嘲热讽，他们唯一能做的， 也是大部分人的选择， 就是不停地给各种公开发表的报刊的编辑们写信。

可想而知，有的信件的措辞并不那么友善，甚至是非常负面的。但是，也不乏强烈支持者。总之，这场火热的争论持续了超过10 年。

当然，这场辩论最终还是逐渐停止了。原因很简单： Dijkstra 是对的。随着编程语言的演进， goto 语句的重要性越来越小，最终甚至消失了。如今大部分的现代编程语言中都己经没有了 goto 语句。哦， 对了， LISP 里从来就没有过！

现如今，无论是否自愿，我们都是结构化编程范式的践行者了，因为我们用的编程语言基本上都己经禁止了不受限制的直接控制转移语句。

或许有些人会指出， Java 中的带命名的break 语句或者E xception 都和goto很类似。事实上，这些语法结构与老的编程语言（类似FORTRAN 和COBOL ）中的完全无限制的g o to 语句根本不一样。就算那些还支持g o to 关键词的编程语言也通常限制了g o to 的目标不能超出当前函数范围。

## 功能性降解拆分

既然结构化编程范式可将模块递归降解拆分为可推导的单元，这就意味着模块
也可以按功能进行降解拆分。这样一来，我们就可以将一个大型问题拆分为一系列
高级函数的组合，而这些高级函数各自又可以继续被拆分为一系列低级函数，如此
无限递归。更重要的是， 每个被拆分出来的函数也都可以用结构化编程范式来书写。

以此为理论基础，在2 0 世纪7 0 年代晚期到8 0 年代中期出现的结构化分析与结
构化设计工作才能广为人知。E d You rdon 、Larry Co n stantine 、Tom D eMarco 以及
Meilir Page Jones 在这期间为此做了很多推广工作。通过采用这些技巧，程序员可以
将大型系统设计拆分成模块和组件，而这些模块和组件最终可以拆分为更小的、可
证明的函数。

## 形式化证明没有发生

但是，人人都用完整的形式化证明的一天没有到来。大部分人不会真的按照欧
几里得结构为每个小函数书写冗长复杂的正确性证明过程。。D ijkstra 的梦想最终并
没有实现。没有几个程序员会认为形式化验证是产出高质量软件的必备条件。

当然，形式化的、欧几里得式的数学推导证明并不是证明结构化编程正确性的
唯一手段。下面我们来看另外一个十分成功的策略：科学证明法。

## 科学来救场

科学和数学在证明方法上有着根本性的不同，科学理论和科学定律通常是无法
被证明的，譬如我们并没有办法证明牛顿第二运动定律F=ma 或者万有引力定律
F=Gm1m21r2 是正确的，但我们可以用实际案例来演示这些定律的正确性，并通过高精度测量来证明当相关精度达到小数点后多少位时，被测量对象仍然一直满足这个
定律。但我们始终没有办法像用数学方法一样推导出这个定律。而且，不管我们进
行多少次正确的实验，也无法排除今后会存在某一次实验可以推翻牛顿第二运动定
律与万有引力定律的可能性。

这就是科学理论和科学定律的特点：它们可以被证伪，但是没有办法被证明。

但是我们仍然每天都在依赖这些定律生活。开车的时候，我们就等于是在用性
命担保F=ma 是对世界运转方式的一个可靠的描述。每当我们迈出一步的时候，就
等于在亲身证明F=Gm1m21r2 是正确的。

科学方法论不需要证明某条结论是正确的，只需要想办法证明它是错误的。如
果某个结论经过一定的努力无法证伪，我们则认为它在当下是足够正确的。

当然，不是所有的结论都可以被证明或者证伪的。举一个最简单的不可证明的
例子： “这句话是假的”，非真也非伪。

最终，我们可以说数学是要将可证明的结论证明，而与之相反，科学研究则是
要将可证明的结论证伪。

## 测试

Dijkstra 曾经说过“测试只能展示Bug 的存在，并不能证明不存在Bug ”，换句
话说， 一段程序可以由一个测试来证明其错误性，但是却不能被证明是正确的。测
试的作用是让我们得出某段程序己经足够实现当前目标这一结论。

这一事实所带来的影响是惊人的。软件开发虽然看起来是在操作很多数学结构，
其实不是一个数学研究过程。恰恰相反，软件开发更像是一门科学研究学科，我们
通过无法证伪来证明软件的正确性。

注意，这种证伪过程只能应用于可证明的程序上。某段程序如果是不可证明的，
例如，其中采用了不加限制的goto 语句，那么无论我们为它写多少测试，也不能
够证明其正确性。

结构化编程范式促使我们先将一段程序递归降解为一系列可证明的小函数，然
后再编写相关的测试来试图证明这些函数是错误的。如果这些测试无法证伪这些函
数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。

## 本章小结

结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的
能力。这就是为什么现代编程语言一般不支持无限制的goto 语句。更重要的是，
这也是为什么在架构设计领域，功能性降解拆分仍然是最佳实践之一。

无论在哪一个层面上，从最小的函数到最大组件，软件开发的过程都和科学研
究非常类似，它们都是由证伪驱动的。软件架构师需要定义可以方便地进行证伪（测
试）的模块、组件以及服务。为了达到这个目的，他们需要将类似结构化编程的限
制方法应用在更高的层面上。

我们在接下来的章节中将会深入研究这些限制性的方法。

# 面向对象编程

稍后我们会讲到，设计一个优秀的软件架构要基于对面向对象设计
( Object-Oriented De s i g n ）的深入理解及应用。但我们首先得弄明白一个问题： 究竟
什么是面向对象？

对于这个问题， 一种常见的回答是“数据与函数的组合“。这种说法虽然被广
为引用，但总显得井不是那么贴切，因为它似乎暗示了。. f （）与f(o ）之间是有区
别的，这显然不是事实。面向对象理论是在1966 年提出的，当时Dahl 和Nygaard
主要是将函数调用技迁移到了堆区域中。数据结构被用作函数的调用参数这件事情
远比这发生的时间更早。

另一种常见的回答是“面向对象编程是一利1 对真实世界进行建模的方式“，这
种回答只能算作避重就轻。“对真实世界的建模”到底要如何进行？我们为什么要
这么做，有什么好处？也许这句话意味着是“由于采用面向对象方式构建的软件与
真实世界的关系更紧密，所以面向对象编程可以使得软件开发更容易”一一即使这
样说， 也仍然逃避了关键问题一一面向对象编程究竟是什么？

还有些人在回答这个问题的时候，往往会搬出一些神秘的词语， 譬如封装
(e n c apsulation ） 、继承（ inh e ritance ） 、多态（polymorphism ） 。其隐含意思就是说
面向对象编程是这三顶的有机组合，或者任何一种支持面向对象的编程语言必须支
持这三个特性。

那么，我们接下来可以逐个来分析一下这三个概念。

## 封装

由于面向对象编程语言为我们方便而有效地封装数据和函数提供了有力的支持，
导致封装这个概念经常被引用为面向对象编程定义的一部分。通过采用封装特性，
我们可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，
数据则完全不可见。譬如， 在实际应用中，类（ class ）中的公共函数和私有成员变
量就是这样。

然而， 这个特性其实并不是面向对象编程所独有的。其实， C 语言也支持完整的封装，下面来看一个简单的C 程序：

显然，使用point . h 的程序是没有Poin t 结构体成员的访问权限的。它们只
能调用makePo i nt （）函数和distance （）函数，但对它们来说， Point 这个数据
结构体的内部细节，以及函数的具体实现方式都是不可见的。

这正是完美封装一一虽然C 语言是非面向对象的编程语言。上述C 程序是很常
见的。在头文件中进行数据结构以及函数定义的前置声明（ forward declare ），然后
在程序文件中具体实现。程序文件中的具体实现细节对使用者来说是不可见的。

而C＋＋作为一种面向对象编程语言，反而破坏了C 的完美封装性。

由于一些技术原因i,C ＋＋编译器要求类的成员变量必须在该类的头文件中声明。
这样一来，我们的p oint . h 程序随之就改成了这样：

好了， point.h 文件的使用者现在知道了成员变量x 和y 的存在！虽然编译器
会禁止对这两个变量的直接访问，但是使用者仍然知道了它们的存在。而且，如果
x 和y 变量名称被改变了， point . cc 也必须重新编译才行！ 这样的封装性显然是
不完美的。

当然， C ＋＋通过在编程语言层面引入public 、private 、protected 这些关
键词，部分维护了封装性。但所有这些都是为了解决编译器自身的技术实现问题而引入的hack－一编译器由于技术实现原因必须在头文件中看到成员变量的定义。

而Java 和C＃则彻底抛弃了头文件与实现文件分离的编程方式，这其实进一步
削弱了封装性。因为在这些语言中，我们是无法区分一个类的声明和定义的。

由于上述原因，我们很难说强封装是面向对象编程的必要条件。而事实上，有
很多面向对象编程语言l对封装性并没有强制性的要求。

面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。但实际
情况是，那些声称自己提供面向对象编程支持的编程语言，相对于C 这种完美封装
的语言而言，其封装性都被削弱了，而不是加强了。

## 继承

既然面向对象编程语言并没有提供更好的封装性，那么在继承性方面又如何
呢？

嗯，其实也就一般般吧。简而言之，继承的主要作用是让我们可以在某个作用
域内对外部定义的某一组变量与函数进行覆盖。这事实上也是C 程序员2早在面向对
象编程语言发明之前就一直在做的事了。

下面， 看一下刚才的C 程序point . h 的扩展版：

请仔细观察main 函数，这里NarnedPoint 数据结构是被当作Po i nt 数据结构的一个衍生体来使用的。之所以可以这样做，是因为NamedPoint 结构体的前两
个成员的顺序与P o int 结构体的完全一致。简单来说， NamedPoint 之所以可以
被伪装成Point 来使用，是因为NamedPoint 是Point 结构体的一个超集，同时
两者共同成员的顺序也是一样的。

上面这种编程方式虽然看上去有些投机取巧，但是在面向对象理论被提出之前，
这己经很常见了l 。其实， C＋＋内部就是这样实现单继承的。

因此，我们可以说，早在面向对象编程语言被发明之前，对继承性的支持就己
经存在很久了。当然了，这种支持用了一些投机取巧的手段，并不像如今的继承这
样便利易用，而且，多重继承（ multiple inheritance ）如果还想用这种方法来实现，
就更难了。

同时应该注意的是，在main .c 中，程序员必须强制将NamedPoint 的参数类
型转换为Point ，而在真正的面向对象编程语言中，这种类型的向上转换通常应该
是隐性的。

综上所述，我们可以认为，虽然面向对象编程在继承性方面并没有开创出新，
但是的确在数据结构的伪装性上提供了相当程度的便利性。

回顾一下到目前为止的分析，面向对象编程在封装性上得0 分，在继承性上勉
强可以得0.5 分（满分为1 ）。

下面，我们还有最后一个特性要讨论。

## 多态

在面向编程对象语言被发明之前，我们所使用的编程语言能支持多态吗？

答案是肯定的，请注意看下面这段用C 语言编写的copy 程序：

在上述程序中，函数getchar （）主要负责从ST DIN 中读取数据。但是STDIN
究竟指代的是哪个设备呢？同样的道理， putchar （）主要负责将数据写入STDOUT,
而ST DO UT 又指代的是哪个设备呢？很显然，这类函数其实就具有多态性，因为它
们的行为依赖于ST DIN 和STDOUT 的具体类型。

这里的STD IN 和ST DO UT 与Java 中的接口类似，各种设备都有各自的实现。
当然，这个C 程序中是没有接口这个概念的，那么getchar （）这个调用的动作是
如何真正传递到设备驱动程序中，从而读取到具体内容的呢？

其实很简单， UNIX 操作系统强制要求每个IO 设备都要提供ope 口、close 、
read 、write 和seek 这5 个标准函数。l 也就是说，每个IO 设备驱动程序对这5
种函数的实现在函数调用上必须保持一致。

首先， FILE 数据结构体中包含了相对应的5 个函数指针，分别用于指向这些函
数：

然后，譬如控制台设备的IO 驱动程序就会提供这5 个函数的实际定义，将FILE
结构体的函数指针指向这些对应的实现函数：

现在， 如果ST DIN 的定义是FILE 女，并同时指向了cons ole 这个数据结构，
那么getchar （）的实现方式就是这样的：

换句话说， getchar （） 只是调用了ST DIN 所指向的FILE 数据结构体中的
read 函数指针指向的函数。

这个简单的编程技巧正是面向对象编程中多态的基础。例如在C＋＋中， 类中的
每个虚函数（ vir阳a l ：“nction ）的地址都被记录在一个名叫v table 的数据结构里。
我们对虚函数的每次调用都要先查询这个表，其衍生类的构造函数负责将该衍生类
的虚函数地址加载到整个对象的vtable 中。

归根结底，多态其实不过就是函数指针的一种应用。自从2 0 世纪40 年代末期
冯·诺依曼架构诞生那天起，程序员们就一直在使用函数指针模拟多态了。也就是
说，面向对象编程在多态方面没有提出任何新概念。

当然了，面向对象编程语言虽然在多态上并没有理论创新，但它们也确实让多
态变得更安全、更便于使用了。

用函数指针显式实现多态的问题就在于函数指针的危险性。毕竟，函数指针的
调用依赖于一系列需要人为遵守的约定。程序员必须严格按照固定约定来初始化函
数指针，并同样严格地按照约定来调用这些指针。只要有一个程序员没有遵守这些约定，整个程序就会产生极其难以跟踪和消除的Bug 。

面向对象编程语言为我们消除了人工遵守这些约定的必要，也就等于消除了这
方面的危险性。采用面向对象编程语言让多态实现变得非常简单，让一个传统C 程
序员可以去做以前不敢想的事情。综上所述，我们认为面向对象编程其实是对程序
间接控制权的转移进行了约束。

### 多态的强大性

那么多态的优势在哪里呢？为了让读者更好地理解多态的好处，我们需要再来
看一下刚才的copy 程序。如果要支持新的IO 设备，该程序需要做什么改动呢？譬
如，假设我们想要用该copy 程序从一个手写识别设备将数据复制到另一个语音合
成设备中，我们需要针对copy 程序做什么改动，才能实现这个目标呢？

答案是完全不需要做任何改动！ 确实，我们甚至不需要重新编译该copy 程序。
为什么？因为copy 程序的源代码并不依赖于IO 设备驱动程序的代码。只要IO 设
备驱动程序实现了FILE 结构体中定义的5 个标准函数，该copy 程序就可以正常
使用它们。

简单来说， IO 设备变成了copy 程序的插件。

为什么UNIX 操作系统会将IO 设备设计成插件形式呢？因为自20 世纪50 年代
末期以来，我们学到了一个重要经验： 程序应该与设备无关。这个经验从何而来呢？
因为一度所有程序都是设备相关的，但是后来我们发现自己其实真正需要的是在不
同的设备上实现同样的功能。

例如，我们曾经写过一些程序，需要从卡片盒中的打孔卡片l 读取数据，同时要
通过在新的卡片上打孔来输出数据。后来，客户不再使用打孔卡片，而开始使用磁
带卷了。这就给我们带来了很多麻烦，很多程序都需要重写。于是我们就会想，如
果这段程序可以同时操作打孔卡片和磁带那该多好。

插件式架构就是为了支持这种IO 不相关性而发明的，它几乎在随后的所有操作
系统中都有应用。但即使多态有如此多优点，大部分程序员还是没有将插件特性引
入他们自己的程序中，因为函数指针实在是太危险了。

而面向对象编程的出现使得这种插件式架构可以在任何地方被安全地使用。

### 依赖反转

我们可以想象一下在安全和便利的多态支持出现之前，软件是什么样子的。下
面有一个典型的调用树的例子， main 函数调用了一些高层函数，这些高层函数又调
用了一些中层函数，这些中层函数又继续调用了一些底层函数。在这里，源代码层
面的依赖不可避免地要跟随程序的控制流（详见图5.1 ）。

如你所见， main 函数为了调用高层函数，它就必须能够看到这个函数所在的模
块。在C 中，我们会通过＃ include 来实现，在Java 中则通过import 来实现，而
在C＃中则用的是usi 口q 语句。总之，每个函数的调用方都必须要引用被调用方所
在的模块。

显然，这样做就导致了我们在软件架构上别无选择。在这里，系统行为决定了
控制流，而控制流则决定了源代码依赖关系。

但一旦我们使用了多态，情况就不一样了（详见图5.2 ）。
φ

在图5.2 中，模块HLl 调用了MLl 模块中的F （）函数，这里的调用是通过源代
码级别的接口来实现的。当然在程序实际运行时，接口这个概念是不存在的， HLl
会调用MLl 中的F （）函数l 。

请注意模块MLl 和接口I 在源代码上的依赖关系（或者叫继承关系〉，该关系
的方向和控制流正好是相反的，我们称之为依赖反转。这种反转对软件架构设计的
影响是非常大的。

事实上，通过利用面向编程语言所提供的这种安全便利的多态实现，无论我们
面对怎样的源代码级别的依赖关系，都可以将其反转。

现在，我们可以再回头来看图5.1 中的调用树，就会发现其中的众多源代码依
赖关系都可以通过引入接口的方式来进行反转。

通过这种方法，软件架构师可以完全拉制采用了面向对象这种编程方式的系统
中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者
被调用，软件架构师都可以随意更改源代码依赖关系。

这就是面向对象编程的好处，同时也是面向对象编程这种范式的核心本质一一
至少对一个软件架构师来说是这样的。

这种能力有什么用呢？在下面的例子中，我们可以用它来让数据库模块和用户
界面模块都依赖于业务逻辑模块（ 见图5.3 ） ，而非相反。

这意味着我们让用户界面和数据库都成为业务逻辑的插件。也就是说，业务逻
辑模块的源代码不需要引入用户界面和数据库这两个模块。

这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件或
者部署单元（例如jar 文件、DLL 文件、Gem 文件等）了，这些组件或者部署单元
的依赖关系与源代码的依赖关系是一致的，业务逻辑组件也不会依赖于用户界面和
数据库这两个组件。

于是，业务逻辑组件就可以独立于用户界面和数据库来进行部署了，我们对用
户界面或者数据库的修改将不会对业务逻辑产生任何影响，这些组件都可以被分别、
独立地部署。

简单来说，当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需
要更改其他组件，这就是拙立部署能力。

如果系统中的所有组件都可以独立部署，那它们就可以由不同的团队并行开发，
这就是所谓的独立开发能力。

## 本章小结

面向对象编程到底是什么？业界在这个问题上存在着很多不同的说法和意见。
然而对一个软件架构师来说，其含义应该是非常明确的：面向对象编程就是以多态
为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建
出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被
编译成插件，实现独立于高层组件的开发和部署。