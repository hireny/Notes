--缓存--

在面向对象的程序设计中，数据及其操作被封装在一个个称为对象（object）的统一体中，对象之间则通过消息（message）相互联系，“对象+消息”的机制取代了“数据结构+算法”的思路，因而较好地实现了解空间与问题空间的一致性，从而为解决软件为记带来了新的希望。从面向过程程序设计到面向对象程序设计（object-oriented programming，OOP），是程序设计方法的又一次飞跃，目前正日益显露出其优越性。

为便于对照，请读者先看一个简单的例子——银行储蓄处理事务。这一事务包含一个数据（账号余额）和 3 个对数据的操作——存款、取款与利息结算（每年度一次）。图显示了使用两类不同编程范式实现这一事务的模型。

在采用过程式编程范型中，如（a）所示，数据“账户余额”与施加在其上的操作时分离的，存款、取款与利息结算等 3 个过程模块分别将相应的操作施加于“账户余额”，使数据获得更新。图（b）则采用面向对象编程范型，存款、取款与利息结算作为对象内部的 3 个事务过程，与“账户余额”一起封装在“银行账户”对象中，通过来自对象外部的3中不同的消息（图（b）中箭头所示），即可启动相应的操作。

两者对照，面向对象编程范型具有明显的优势。首先，在图（a）中，存款、取款与利息结算都是分离的单个模块，而在图（b）中，“银行账户”对象一般是由多个模块组成的一个独立的单元。而且由于解空间与问题空间的一致性，软件开发人员对客观世界建立的分析模型，实际上已为软件系统的设计准备好了基本的框架。因而在大型程序的开发中，采用面向对象模型范型可以有效地降低软件的复杂性，简化软件的开发。

面向对象编程范型的优势也体现在软件的维护上。假定图（a）中的“账户余额”在开发时使用了整型数，维护时要改变为浮点型，则该软件中凡与“账户余额”有关的程序均需修改。但如果采用图（b）中的面向对象编程范型，则上述改变将限于“银行账户”对象本身，与该对象以外的其他部分以及触发该对象操作的外部消息完全无关。这将使因修改程序而引发软件故障的机会大大减少，使得大型软件的维护更加容易和快捷。

--缓存--

# 面向对象编程

说到编程领域中第二个被广泛采用的编程范式，当然就是面向对象编程了。事实上，这个编程范式的提出比结构化编程还早了两年，是在 1966 年由 Ole Johan Dahl 和 Kriste Nygaard 在论文中总结归纳出来的。这两个程序员注意到了 ALGOL 语言中，函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这个函数就成为了一个类（class）的构造函数，而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法（method）。这样一来，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。

在这里，我们也可以用一句话来总结面向对象编程：

卖相对象编程对程序的控制权的间接转移进行了限制和规范。

# 面向对象编程

稍后我们会讲到，设计一个优秀的软件架构要基于对面向对象设计
( Object-Oriented De s i g n ）的深入理解及应用。但我们首先得弄明白一个问题： 究竟
什么是面向对象？

对于这个问题， 一种常见的回答是“数据与函数的组合“。这种说法虽然被广为引用，但总显得井不是那么贴切，因为它似乎暗示了。. f （）与f(o ）之间是有区别的，这显然不是事实。面向对象理论是在1966 年提出的，当时Dahl 和Nygaard主要是将函数调用技迁移到了堆区域中。数据结构被用作函数的调用参数这件事情远比这发生的时间更早。

另一种常见的回答是“面向对象编程是一利1 对真实世界进行建模的方式“，这种回答只能算作避重就轻。“对真实世界的建模”到底要如何进行？我们为什么要这么做，有什么好处？也许这句话意味着是“由于采用面向对象方式构建的软件与真实世界的关系更紧密，所以面向对象编程可以使得软件开发更容易”一一即使这样说， 也仍然逃避了关键问题一一面向对象编程究竟是什么？

还有些人在回答这个问题的时候，往往会搬出一些神秘的词语， 譬如封装(e n c apsulation ） 、继承（ inh e ritance ） 、多态（polymorphism ） 。其隐含意思就是说面向对象编程是这三顶的有机组合，或者任何一种支持面向对象的编程语言必须支持这三个特性。

那么，我们接下来可以逐个来分析一下这三个概念。

## 封装

由于面向对象编程语言为我们方便而有效地封装数据和函数提供了有力的支持，导致封装这个概念经常被引用为面向对象编程定义的一部分。通过采用封装特性，我们可以把一组相关联的数据和函数圈起来，使圈外面的代码只能看见部分函数，数据则完全不可见。譬如， 在实际应用中，类（ class ）中的公共函数和私有成员变量就是这样。

然而， 这个特性其实并不是面向对象编程所独有的。其实， C 语言也支持完整的封装，下面来看一个简单的C 程序：

显然，使用point . h 的程序是没有Poin t 结构体成员的访问权限的。它们只能调用makePo i nt （）函数和distance （）函数，但对它们来说， Point 这个数据结构体的内部细节，以及函数的具体实现方式都是不可见的。

这正是完美封装一一虽然C 语言是非面向对象的编程语言。上述C 程序是很常见的。在头文件中进行数据结构以及函数定义的前置声明（ forward declare ），然后在程序文件中具体实现。程序文件中的具体实现细节对使用者来说是不可见的。

而C＋＋作为一种面向对象编程语言，反而破坏了C 的完美封装性。

由于一些技术原因i,C ＋＋编译器要求类的成员变量必须在该类的头文件中声明。这样一来，我们的p oint . h 程序随之就改成了这样：

好了， point.h 文件的使用者现在知道了成员变量x 和y 的存在！虽然编译器会禁止对这两个变量的直接访问，但是使用者仍然知道了它们的存在。而且，如果x 和y 变量名称被改变了， point . cc 也必须重新编译才行！ 这样的封装性显然是不完美的。

当然， C ＋＋通过在编程语言层面引入public 、private 、protected 这些关键词，部分维护了封装性。但所有这些都是为了解决编译器自身的技术实现问题而引入的hack－一编译器由于技术实现原因必须在头文件中看到成员变量的定义。

而Java 和C＃则彻底抛弃了头文件与实现文件分离的编程方式，这其实进一步削弱了封装性。因为在这些语言中，我们是无法区分一个类的声明和定义的。

由于上述原因，我们很难说强封装是面向对象编程的必要条件。而事实上，有很多面向对象编程语言l对封装性并没有强制性的要求。

面向对象编程在应用上确实会要求程序员尽量避免破坏数据的封装性。但实际情况是，那些声称自己提供面向对象编程支持的编程语言，相对于C 这种完美封装的语言而言，其封装性都被削弱了，而不是加强了。

## 继承

既然面向对象编程语言并没有提供更好的封装性，那么在继承性方面又如何呢？

嗯，其实也就一般般吧。简而言之，继承的主要作用是让我们可以在某个作用域内对外部定义的某一组变量与函数进行覆盖。这事实上也是C 程序员2早在面向对象编程语言发明之前就一直在做的事了。

下面， 看一下刚才的C 程序point . h 的扩展版：

请仔细观察main 函数，这里NarnedPoint 数据结构是被当作Po i nt 数据结构的一个衍生体来使用的。之所以可以这样做，是因为NamedPoint 结构体的前两个成员的顺序与P o int 结构体的完全一致。简单来说， NamedPoint 之所以可以被伪装成Point 来使用，是因为NamedPoint 是Point 结构体的一个超集，同时两者共同成员的顺序也是一样的。

上面这种编程方式虽然看上去有些投机取巧，但是在面向对象理论被提出之前，这己经很常见了l 。其实， C＋＋内部就是这样实现单继承的。

因此，我们可以说，早在面向对象编程语言被发明之前，对继承性的支持就己经存在很久了。当然了，这种支持用了一些投机取巧的手段，并不像如今的继承这样便利易用，而且，多重继承（ multiple inheritance ）如果还想用这种方法来实现，就更难了。

同时应该注意的是，在main .c 中，程序员必须强制将NamedPoint 的参数类型转换为Point ，而在真正的面向对象编程语言中，这种类型的向上转换通常应该是隐性的。

综上所述，我们可以认为，虽然面向对象编程在继承性方面并没有开创出新，但是的确在数据结构的伪装性上提供了相当程度的便利性。

回顾一下到目前为止的分析，面向对象编程在封装性上得0 分，在继承性上勉强可以得0.5 分（满分为1 ）。

下面，我们还有最后一个特性要讨论。

## 多态

在面向编程对象语言被发明之前，我们所使用的编程语言能支持多态吗？

答案是肯定的，请注意看下面这段用C 语言编写的copy 程序：

在上述程序中，函数getchar （）主要负责从ST DIN 中读取数据。但是STDIN究竟指代的是哪个设备呢？同样的道理， putchar （）主要负责将数据写入STDOUT,而ST DO UT 又指代的是哪个设备呢？很显然，这类函数其实就具有多态性，因为它们的行为依赖于ST DIN 和STDOUT 的具体类型。

这里的STD IN 和ST DO UT 与Java 中的接口类似，各种设备都有各自的实现。当然，这个C 程序中是没有接口这个概念的，那么getchar （）这个调用的动作是如何真正传递到设备驱动程序中，从而读取到具体内容的呢？

其实很简单， UNIX 操作系统强制要求每个IO 设备都要提供ope 口、close 、read 、write 和seek 这5 个标准函数。l 也就是说，每个IO 设备驱动程序对这5种函数的实现在函数调用上必须保持一致。

首先， FILE 数据结构体中包含了相对应的5 个函数指针，分别用于指向这些函数：

然后，譬如控制台设备的IO 驱动程序就会提供这5 个函数的实际定义，将FILE结构体的函数指针指向这些对应的实现函数：

现在， 如果ST DIN 的定义是FILE 女，并同时指向了cons ole 这个数据结构，那么getchar （）的实现方式就是这样的：

换句话说， getchar （） 只是调用了ST DIN 所指向的FILE 数据结构体中的read 函数指针指向的函数。

这个简单的编程技巧正是面向对象编程中多态的基础。例如在C＋＋中， 类中的每个虚函数（ vir阳a l ：“nction ）的地址都被记录在一个名叫v table 的数据结构里。我们对虚函数的每次调用都要先查询这个表，其衍生类的构造函数负责将该衍生类的虚函数地址加载到整个对象的vtable 中。

归根结底，多态其实不过就是函数指针的一种应用。自从2 0 世纪40 年代末期冯·诺依曼架构诞生那天起，程序员们就一直在使用函数指针模拟多态了。也就是说，面向对象编程在多态方面没有提出任何新概念。

当然了，面向对象编程语言虽然在多态上并没有理论创新，但它们也确实让多态变得更安全、更便于使用了。

用函数指针显式实现多态的问题就在于函数指针的危险性。毕竟，函数指针的调用依赖于一系列需要人为遵守的约定。程序员必须严格按照固定约定来初始化函数指针，并同样严格地按照约定来调用这些指针。只要有一个程序员没有遵守这些约定，整个程序就会产生极其难以跟踪和消除的Bug。

面向对象编程语言为我们消除了人工遵守这些约定的必要，也就等于消除了这方面的危险性。采用面向对象编程语言让多态实现变得非常简单，让一个传统C 程序员可以去做以前不敢想的事情。综上所述，我们认为面向对象编程其实是对程序间接控制权的转移进行了约束。

### 多态的强大性

那么多态的优势在哪里呢？为了让读者更好地理解多态的好处，我们需要再来看一下刚才的copy 程序。如果要支持新的IO 设备，该程序需要做什么改动呢？譬如，假设我们想要用该copy 程序从一个手写识别设备将数据复制到另一个语音合成设备中，我们需要针对copy 程序做什么改动，才能实现这个目标呢？

答案是完全不需要做任何改动！ 确实，我们甚至不需要重新编译该copy 程序。为什么？因为copy 程序的源代码并不依赖于IO 设备驱动程序的代码。只要IO 设备驱动程序实现了FILE 结构体中定义的5 个标准函数，该copy 程序就可以正常使用它们。

简单来说， IO 设备变成了copy 程序的插件。

为什么UNIX 操作系统会将IO 设备设计成插件形式呢？因为自20 世纪50 年代末期以来，我们学到了一个重要经验： 程序应该与设备无关。这个经验从何而来呢？因为一度所有程序都是设备相关的，但是后来我们发现自己其实真正需要的是在不同的设备上实现同样的功能。

例如，我们曾经写过一些程序，需要从卡片盒中的打孔卡片l 读取数据，同时要通过在新的卡片上打孔来输出数据。后来，客户不再使用打孔卡片，而开始使用磁带卷了。这就给我们带来了很多麻烦，很多程序都需要重写。于是我们就会想，如果这段程序可以同时操作打孔卡片和磁带那该多好。

插件式架构就是为了支持这种IO 不相关性而发明的，它几乎在随后的所有操作系统中都有应用。但即使多态有如此多优点，大部分程序员还是没有将插件特性引入他们自己的程序中，因为函数指针实在是太危险了。

而面向对象编程的出现使得这种插件式架构可以在任何地方被安全地使用。

### 依赖反转

我们可以想象一下在安全和便利的多态支持出现之前，软件是什么样子的。下面有一个典型的调用树的例子， main 函数调用了一些高层函数，这些高层函数又调用了一些中层函数，这些中层函数又继续调用了一些底层函数。在这里，源代码层面的依赖不可避免地要跟随程序的控制流（详见图5.1 ）。

如你所见， main 函数为了调用高层函数，它就必须能够看到这个函数所在的模块。在C 中，我们会通过＃ include 来实现，在Java 中则通过import 来实现，而在C＃中则用的是usi 口q 语句。总之，每个函数的调用方都必须要引用被调用方所在的模块。

显然，这样做就导致了我们在软件架构上别无选择。在这里，系统行为决定了控制流，而控制流则决定了源代码依赖关系。

但一旦我们使用了多态，情况就不一样了（详见图5.2 ）。φ

在图5.2 中，模块HLl 调用了MLl 模块中的F （）函数，这里的调用是通过源代码级别的接口来实现的。当然在程序实际运行时，接口这个概念是不存在的， HLl会调用MLl 中的F （）函数l 。

请注意模块MLl 和接口I 在源代码上的依赖关系（或者叫继承关系〉，该关系的方向和控制流正好是相反的，我们称之为依赖反转。这种反转对软件架构设计的影响是非常大的。

事实上，通过利用面向编程语言所提供的这种安全便利的多态实现，无论我们面对怎样的源代码级别的依赖关系，都可以将其反转。

现在，我们可以再回头来看图5.1 中的调用树，就会发现其中的众多源代码依赖关系都可以通过引入接口的方式来进行反转。

通过这种方法，软件架构师可以完全拉制采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。

这就是面向对象编程的好处，同时也是面向对象编程这种范式的核心本质一一至少对一个软件架构师来说是这样的。

这种能力有什么用呢？在下面的例子中，我们可以用它来让数据库模块和用户界面模块都依赖于业务逻辑模块（ 见图5.3 ） ，而非相反。

这意味着我们让用户界面和数据库都成为业务逻辑的插件。也就是说，业务逻辑模块的源代码不需要引入用户界面和数据库这两个模块。

这样一来，业务逻辑、用户界面以及数据库就可以被编译成三个独立的组件或者部署单元（例如jar 文件、DLL 文件、Gem 文件等）了，这些组件或者部署单元的依赖关系与源代码的依赖关系是一致的，业务逻辑组件也不会依赖于用户界面和数据库这两个组件。

于是，业务逻辑组件就可以独立于用户界面和数据库来进行部署了，我们对用户界面或者数据库的修改将不会对业务逻辑产生任何影响，这些组件都可以被分别、独立地部署。

简单来说，当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其他组件，这就是拙立部署能力。

如果系统中的所有组件都可以独立部署，那它们就可以由不同的团队并行开发，这就是所谓的独立开发能力。

## 本章小结

面向对象编程到底是什么？业界在这个问题上存在着很多不同的说法和意见。然而对一个软件架构师来说，其含义应该是非常明确的：面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。