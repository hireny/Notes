Java I/O 是Java提供的一套关于输入和输出的编程接口。里面包含操作输入和输出所需要的类。

流的概念：TCP中的流指的是流入到进程或从进程流出的字节序列。

Java中IO流分为：

- 按照流，可以分为输入流和输出流；
- 按照操作单元划分，可以分为字节流和字符流；
- 按照流的角色划分，可以分为节点流和处理流。

字节流和字符流操作的本质区别只有一个：字节流是原生的操作，字符流是经过处理后的操作。

字节流在操作时不会用到缓冲区，也就是不会用到内存，文件本身直接操作，而字符流在操作时使用了缓冲区，通过缓冲区操作文件。

# 输入/输出流

在 Java I/O APi 中，可以从其中读入一个字节序列的对象称作输入流，可以像其中写入一个字节序列的对象称作输出流。字节序列的来源和目的通常是文件、网络连接或内存块。输入输出流的基类主要是抽象类 `InputStream` 和 `OutputStream`。

因为面向字节的流不便于处理以 Unicode 形式存储的信息，所以从抽象类 Reader 和 Writer 中继承出来了一个专门用于处理 Unicode 字符的单独的类层次结构。这些类拥有的读入和写出操作都是基于两字节的 Char 值的（即，Unicode 码元），而不是基于 byte 值的。

`InputStream`类有一个抽象方法 `abstract int read()`，这个方法将读入一个字节，并返回读入的字节，或者在遇到输入源结尾时返回 `-1`。在设计具体的输入流类时，必须覆盖这个方法以提供适用的功能。例如，在 `FileInputStream` 中，这个方法将从某个文件中读入一个字节，而 `System.in` 却是从 “标准输入” 中读入信息，即控制台或重定向的文件。

`InputStream`类还有若干个非抽象的方法，它们可以读入一个字节数组，或者跳过大量字节。这些方法都要调用抽象的 `read` 方法，因此，各个子类都只需覆盖这一个方法。

与此类似，`OutputStream`类定义了一个抽象方法 `abstract void write(int b)`，可以像某个输出位置写出一个字节。

`read` 和 `write` 方法在执行时都将阻塞，直至字节确实被读入或写出。这意味着如果不能被立即访问，那么当前的线程将被阻塞。这使得在这两个方法等待指定的流变为可用的这段时间里，其它的线程就有机会去执行有用的工作。

`available` 方法使我们可以去检查当前可读入的字节数量，这意味着像下面的代码片段就不能被阻塞：

```java
int bytesAvailable = in.available();
if (bytesAvailable > 0) {
    byte[] data = new byte[bytesAvailable];
    in.read(data);
}
```

当你完成对输入/输出流的读写时，应该通过调用 `close` 方法来关闭它，这个调用会释放掉十分有限的操作系统资源。如果一个应用程序打开了过多的输入/输出流而没有关闭，那么系统资源将被耗尽。关闭一个输出流的同时还会冲刷用于该输出流的缓冲区：所有被临时置于缓冲区中，以便用更大的包的形式传递的字节在关闭输出流时都将被送出。特别是，如果不关闭文件，那么写出字节的最后一个包可能将永远也得不到传递。当然，我们还可以用 `flush` 方法来人为地冲刷这些输出。

即使某个输入/输出流类提供了使用原生的 `read` 和 `write` 功能的某些具体方法，应用系统的程序员还是很少使用它们，因为大家感兴趣的数据可能包含数字、字符串和对象，而不是原生字节。

我们可以使用众多的从基本的 `InputStream` 和 `OutputStream` 类导出的某个输入/输出类，而不只是直接使用字节。

# 字节流

字节流是继承自输入字节流`InputStream`与输出字节流`OutputStream`，它们都是抽象类，是字节流的父类。

`InputStream`常见子类有：

`FileInputStream`从文件中读取信息
`ByteArrayInputStream`字节数组输入流
`ObjectInputStream`序列化时使用一般和ObjectOutputStream一起使用
`FilterInputStream`过滤输入流，为基础的输入流提供一些额外的操作。

# 字符流

`Reader`类是Java IO中所有`Reader`的基类。`Writer`类是Java IO中所有`Writer`的基类。