本章讲述三个编程范式，它们分别是结构化编程（structured programming）、面向对象编程（object-oriented programming）以及函数式编程（functional programming）。

# 结构化编程

结构化编程是第一个普遍被采用的编程范式（但是却不是第一个被提出的），由 Edsger Wybe Dijkstra 于 1968 年最先提出。与此同时，Dijkstra 还论证了使用 goto 这样的无限制跳转语句将会损害程序的整体结构。接下来的章节我们还会说到，也是这位 Dijkstra 最先主张用我们现在熟知的 `if/then/else` 语句和 `do/while/until` 语句来代替跳转语句的。

我们可以将结构化编程范式归结为一句话：

结构化编程对程序控制权的直接转移进行了限制和规范。

# 面向对象编程

说到编程领域中第二个被广泛采用的编程范式，当然就是面向对象编程了。事实上，这个编程范式的提出比结构化编程还早了两年，是在 1966 年由 Ole Johan Dahl 和 Kriste Nygaard 在论文中总结归纳出来的。这两个程序员注意到了 ALGOL 语言中，函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这个函数就成为了一个类（class）的构造函数，而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法（method）。这样一来，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。

在这里，我们也可以用一句话来总结面向对象编程：

卖相对象编程对程序的控制权的间接转移进行了限制和规范。

# 函数式编程

尽管第三个编程范式是近些年才刚刚开始被采用的，但它其实是三个范式中最先被发明的。事实上，函数式编程概念是基于与阿兰·图灵同时代的数学家 Alonzo Church 在 1936 年发明的 λ 演算的直接衍生物。1958 年 John Mccarthy 利用其作为基础发明了 LISP 语言。众所周知，λ 演算法的一个核心思想是不可变性 —— 某个符号所对应的值是永远不变的，所以从理论上来说，函数式编程语言中应该是没有赋值语句的。大部分函数式编程语言只允许在非常严格的限制条件下，才可以更改某个变量的值。

因此，我们在这里可以将函数式编程范式总结为下面这句话：

函数式编程对程序中的赋值进行了限制和规范。

# 仅供思考

如你所见，我在介绍三个编程范式的时候，有意采用了上面这种格式，目的是凸显每个编程范式的实际含义 —— 它们都从某一方面限制和规范了程序员的能力。没有一个范式是增加新能力的。也就是说，每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。

另外，我们应该认识到，这三个编程范式分别限制了 goto 语句、函数指针和赋值语句的使用。那么除此之外，还有什么可以去除的呢？

没有了。因此这三个编程范式可能是仅有三个了 —— 如果单论去除能力的编程范式的话。支持者一结论的另外一个论据是，三个编程范式都是在 1958 年到 1968 年这 10 年间被提出来的，后续再也没有新的编程范式出现过。

# 本章小结

大家可能会问，这些编程范式的历史知识与软件架构有关系吗？当然有，而且关系相当密切。譬如说，多态是我们跨域架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各模块的算法实现基础。

这和软甲架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。

# 结构化编程

Edsger Wybe Dijkstra 于1930 年出生在荷兰鹿特丹。生于乱世，他亲身经历了第二次世界大战中的鹿特丹大轰炸、德国占领荷兰等事件。1948 年， 他以数学、物理、化学以及生物全满分的成绩高中毕业。1952 年3 月，年仅21 岁的Dijkstra （此时距离我出生还有9 个月时间）入职荷兰阿姆斯特丹数学中心，成为了荷兰的第一个程序员。

1955 年，在从事编程工作3 年之后，当时还是一个学生的Dijkstra 就认为编程相比理论物理更有挑战性，因此他选择将编程作为终身职业。

1957 年， Dijkstra 与Maria Debets 结婚了。在当时的荷兰， 新郎新娘必须在结婚仪式上公布自己的职业。而当时的荷兰官方政府拒绝承认“程序员”这一职业，因为他们从来没有听说过。最终D甘kstra 不得不继续使用“理论物理学家”这一职位名称。

Dijkstra 和他的老板Adriaan van Wijingaarden 曾经讨论过将“程序员”当作终身职业这件事， D甘kstra 最担心的是由于没有人认真地对待过编程这件事或者将它当作是一门学术学科对待， 他的科研成果可能将不会得到认真对待。而Adriaan 则建议Dijkstra ： 为什么不亲自去开创这门学科呢？

当时还是真空管阶段。计算机体积巨大，运行缓慢，还非常容易出故障，功能（与今天对比〉十分有限。人们还是直接使用二进制数，或者使用非常原始的汇编语言编程。计算机的输入方式则还是用纸卷带或者是打孔卡片。要想执行完整的编辑、编译、测试流程是非常耗时的，通常需要数小时或者数天才能完成。

Dijkstra 就是在这样原始的条件下做出其非凡的成就的。

## 可推导性

Dijkstra 很早就得出的结论是：编程是一项难度很大的活动。一段程序无论复杂与否，都包含了很多的细节信息。如果没有工具的帮助，这些细节的信息是远远超过一个程序员的认知能力范围的。而在一段程序中，哪怕仅仅是一个小细节的错误，也会造成整个程序出错。

Dijkst ra 提出的解决方案是采用数学推导方法。他的想法是借鉴数学中的公理( Pos tul ate ）、定理（ Th eore m ）、推论（ C orollary ）和引理（ Lemma ），形成一种欧几里得结构。D ijk s tra 认为程序员可以像数学家一样对自己的程序进行推理证明。换句话说，程序员可以用代码将一些己证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。

当然，在这之前，必须先展示如何推导证明简单算法的正确性，这本身就是一件极具挑战性的工作。

Dij kstra 在研究过程中发现了一个问题： goto 语句的某些用法会导致某个模块无法被递归拆分成更小的、可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的部分。

goto i吾句的其他用法虽然不会导致这种问题，但是D ijkstra 意识到它们的实际效果其实和更简单的分支结构if - then - else 以及循环结构do - while 是一致的。如果代码中只采用了这两类控制结构，则一定可以将程序分解成更小的、可证明的单元。

事实上， Dij kstra 很早就知道将这些控制结构与顺序结构的程序组合起来很有用。因为在两年前， B o hm 和Jo c opi ni 刚刚证明了人们可以用顺序结构、分支结构、循环结构这三种结构构造出任何程序。

这个发现非常重要： 因为它证明了我们构建可推导模块所需要的控制结构集与构建所有程序所需的控制结构集的最小集是等同的。这样一来，结构化编程就诞生了。

Dijks tr a 展示了顺序结构的正确性可以通过枚举法证明，其过程与其他一般的数学推导过程是一样的：针对序列中的每个输入，跟踪其对应的输出值的变化就可以了。

同样的， D ij kstra 利用枚举法又证明了分支结构的可推导性。因为我们只要能用枚举法证明分支结构中每条路径的正确性，自然就可以推导出分支结构本身的正确性。

循环结构的证明过程则有些不同，为了证明一段循环程序的正确性， Dijkstra 需要采用数学归纳法。具体来说就是，首先要用枚举法证明循环1 次的正确性。接下来再证明如果循环N 次是正确的，那么循环N＋ ！ 次也同样也是正确的。最后还要用枚举法证明循环结构的起始与结束条件的正确性。

尽管这些证明过程本身非常复杂和烦琐，但确实是完备的。有了这样的证明过程，用欧几里得层级构造定理的方式来验证程序正确性的目标，貌似近在咫尺了。

## goto 是有害的

